{"ast":null,"code":"import { isMac as $28AnR$isMac, isVirtualClick as $28AnR$isVirtualClick, getOwnerWindow as $28AnR$getOwnerWindow, getOwnerDocument as $28AnR$getOwnerDocument } from \"@react-aria/utils\";\nimport { useState as $28AnR$useState, useEffect as $28AnR$useEffect } from \"react\";\nimport { useIsSSR as $28AnR$useIsSSR } from \"@react-aria/ssr\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // Portions of the code in this file are based on code from react.\n// Original licensing for the following can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions\n\nlet $507fabe10e71c6fb$var$currentModality = null;\nlet $507fabe10e71c6fb$var$changeHandlers = new Set();\nlet $507fabe10e71c6fb$export$d90243b58daecda7 = new Map(); // We use a map here to support setting event listeners across multiple document objects.\nlet $507fabe10e71c6fb$var$hasEventBeforeFocus = false;\nlet $507fabe10e71c6fb$var$hasBlurredWindowRecently = false;\n// Only Tab or Esc keys will make focus visible on text input elements\nconst $507fabe10e71c6fb$var$FOCUS_VISIBLE_INPUT_KEYS = {\n  Tab: true,\n  Escape: true\n};\nfunction $507fabe10e71c6fb$var$triggerChangeHandlers(modality, e) {\n  for (let handler of $507fabe10e71c6fb$var$changeHandlers) handler(modality, e);\n}\n/**\n * Helper function to determine if a KeyboardEvent is unmodified and could make keyboard focus styles visible.\n */\nfunction $507fabe10e71c6fb$var$isValidKey(e) {\n  // Control and Shift keys trigger when navigating back to the tab with keyboard.\n  return !(e.metaKey || !(0, $28AnR$isMac)() && e.altKey || e.ctrlKey || e.key === 'Control' || e.key === 'Shift' || e.key === 'Meta');\n}\nfunction $507fabe10e71c6fb$var$handleKeyboardEvent(e) {\n  $507fabe10e71c6fb$var$hasEventBeforeFocus = true;\n  if ($507fabe10e71c6fb$var$isValidKey(e)) {\n    $507fabe10e71c6fb$var$currentModality = 'keyboard';\n    $507fabe10e71c6fb$var$triggerChangeHandlers('keyboard', e);\n  }\n}\nfunction $507fabe10e71c6fb$var$handlePointerEvent(e) {\n  $507fabe10e71c6fb$var$currentModality = 'pointer';\n  if (e.type === 'mousedown' || e.type === 'pointerdown') {\n    $507fabe10e71c6fb$var$hasEventBeforeFocus = true;\n    $507fabe10e71c6fb$var$triggerChangeHandlers('pointer', e);\n  }\n}\nfunction $507fabe10e71c6fb$var$handleClickEvent(e) {\n  if ((0, $28AnR$isVirtualClick)(e)) {\n    $507fabe10e71c6fb$var$hasEventBeforeFocus = true;\n    $507fabe10e71c6fb$var$currentModality = 'virtual';\n  }\n}\nfunction $507fabe10e71c6fb$var$handleFocusEvent(e) {\n  // Firefox fires two extra focus events when the user first clicks into an iframe:\n  // first on the window, then on the document. We ignore these events so they don't\n  // cause keyboard focus rings to appear.\n  if (e.target === window || e.target === document) return;\n  // If a focus event occurs without a preceding keyboard or pointer event, switch to virtual modality.\n  // This occurs, for example, when navigating a form with the next/previous buttons on iOS.\n  if (!$507fabe10e71c6fb$var$hasEventBeforeFocus && !$507fabe10e71c6fb$var$hasBlurredWindowRecently) {\n    $507fabe10e71c6fb$var$currentModality = 'virtual';\n    $507fabe10e71c6fb$var$triggerChangeHandlers('virtual', e);\n  }\n  $507fabe10e71c6fb$var$hasEventBeforeFocus = false;\n  $507fabe10e71c6fb$var$hasBlurredWindowRecently = false;\n}\nfunction $507fabe10e71c6fb$var$handleWindowBlur() {\n  // When the window is blurred, reset state. This is necessary when tabbing out of the window,\n  // for example, since a subsequent focus event won't be fired.\n  $507fabe10e71c6fb$var$hasEventBeforeFocus = false;\n  $507fabe10e71c6fb$var$hasBlurredWindowRecently = true;\n}\n/**\n * Setup global event listeners to control when keyboard focus style should be visible.\n */\nfunction $507fabe10e71c6fb$var$setupGlobalFocusEvents(element) {\n  if (typeof window === 'undefined' || $507fabe10e71c6fb$export$d90243b58daecda7.get((0, $28AnR$getOwnerWindow)(element))) return;\n  const windowObject = (0, $28AnR$getOwnerWindow)(element);\n  const documentObject = (0, $28AnR$getOwnerDocument)(element);\n  // Programmatic focus() calls shouldn't affect the current input modality.\n  // However, we need to detect other cases when a focus event occurs without\n  // a preceding user event (e.g. screen reader focus). Overriding the focus\n  // method on HTMLElement.prototype is a bit hacky, but works.\n  let focus = windowObject.HTMLElement.prototype.focus;\n  windowObject.HTMLElement.prototype.focus = function () {\n    $507fabe10e71c6fb$var$hasEventBeforeFocus = true;\n    focus.apply(this, arguments);\n  };\n  documentObject.addEventListener('keydown', $507fabe10e71c6fb$var$handleKeyboardEvent, true);\n  documentObject.addEventListener('keyup', $507fabe10e71c6fb$var$handleKeyboardEvent, true);\n  documentObject.addEventListener('click', $507fabe10e71c6fb$var$handleClickEvent, true);\n  // Register focus events on the window so they are sure to happen\n  // before React's event listeners (registered on the document).\n  windowObject.addEventListener('focus', $507fabe10e71c6fb$var$handleFocusEvent, true);\n  windowObject.addEventListener('blur', $507fabe10e71c6fb$var$handleWindowBlur, false);\n  if (typeof PointerEvent !== 'undefined') {\n    documentObject.addEventListener('pointerdown', $507fabe10e71c6fb$var$handlePointerEvent, true);\n    documentObject.addEventListener('pointermove', $507fabe10e71c6fb$var$handlePointerEvent, true);\n    documentObject.addEventListener('pointerup', $507fabe10e71c6fb$var$handlePointerEvent, true);\n  } else {\n    documentObject.addEventListener('mousedown', $507fabe10e71c6fb$var$handlePointerEvent, true);\n    documentObject.addEventListener('mousemove', $507fabe10e71c6fb$var$handlePointerEvent, true);\n    documentObject.addEventListener('mouseup', $507fabe10e71c6fb$var$handlePointerEvent, true);\n  }\n  // Add unmount handler\n  windowObject.addEventListener('beforeunload', () => {\n    $507fabe10e71c6fb$var$tearDownWindowFocusTracking(element);\n  }, {\n    once: true\n  });\n  $507fabe10e71c6fb$export$d90243b58daecda7.set(windowObject, {\n    focus: focus\n  });\n}\nconst $507fabe10e71c6fb$var$tearDownWindowFocusTracking = (element, loadListener) => {\n  const windowObject = (0, $28AnR$getOwnerWindow)(element);\n  const documentObject = (0, $28AnR$getOwnerDocument)(element);\n  if (loadListener) documentObject.removeEventListener('DOMContentLoaded', loadListener);\n  if (!$507fabe10e71c6fb$export$d90243b58daecda7.has(windowObject)) return;\n  windowObject.HTMLElement.prototype.focus = $507fabe10e71c6fb$export$d90243b58daecda7.get(windowObject).focus;\n  documentObject.removeEventListener('keydown', $507fabe10e71c6fb$var$handleKeyboardEvent, true);\n  documentObject.removeEventListener('keyup', $507fabe10e71c6fb$var$handleKeyboardEvent, true);\n  documentObject.removeEventListener('click', $507fabe10e71c6fb$var$handleClickEvent, true);\n  windowObject.removeEventListener('focus', $507fabe10e71c6fb$var$handleFocusEvent, true);\n  windowObject.removeEventListener('blur', $507fabe10e71c6fb$var$handleWindowBlur, false);\n  if (typeof PointerEvent !== 'undefined') {\n    documentObject.removeEventListener('pointerdown', $507fabe10e71c6fb$var$handlePointerEvent, true);\n    documentObject.removeEventListener('pointermove', $507fabe10e71c6fb$var$handlePointerEvent, true);\n    documentObject.removeEventListener('pointerup', $507fabe10e71c6fb$var$handlePointerEvent, true);\n  } else {\n    documentObject.removeEventListener('mousedown', $507fabe10e71c6fb$var$handlePointerEvent, true);\n    documentObject.removeEventListener('mousemove', $507fabe10e71c6fb$var$handlePointerEvent, true);\n    documentObject.removeEventListener('mouseup', $507fabe10e71c6fb$var$handlePointerEvent, true);\n  }\n  $507fabe10e71c6fb$export$d90243b58daecda7.delete(windowObject);\n};\nfunction $507fabe10e71c6fb$export$2f1888112f558a7d(element) {\n  const documentObject = (0, $28AnR$getOwnerDocument)(element);\n  let loadListener;\n  if (documentObject.readyState !== 'loading') $507fabe10e71c6fb$var$setupGlobalFocusEvents(element);else {\n    loadListener = () => {\n      $507fabe10e71c6fb$var$setupGlobalFocusEvents(element);\n    };\n    documentObject.addEventListener('DOMContentLoaded', loadListener);\n  }\n  return () => $507fabe10e71c6fb$var$tearDownWindowFocusTracking(element, loadListener);\n}\n// Server-side rendering does not have the document object defined\n// eslint-disable-next-line no-restricted-globals\nif (typeof document !== 'undefined') $507fabe10e71c6fb$export$2f1888112f558a7d();\nfunction $507fabe10e71c6fb$export$b9b3dfddab17db27() {\n  return $507fabe10e71c6fb$var$currentModality !== 'pointer';\n}\nfunction $507fabe10e71c6fb$export$630ff653c5ada6a9() {\n  return $507fabe10e71c6fb$var$currentModality;\n}\nfunction $507fabe10e71c6fb$export$8397ddfc504fdb9a(modality) {\n  $507fabe10e71c6fb$var$currentModality = modality;\n  $507fabe10e71c6fb$var$triggerChangeHandlers(modality, null);\n}\nfunction $507fabe10e71c6fb$export$98e20ec92f614cfe() {\n  $507fabe10e71c6fb$var$setupGlobalFocusEvents();\n  let [modality, setModality] = (0, $28AnR$useState)($507fabe10e71c6fb$var$currentModality);\n  (0, $28AnR$useEffect)(() => {\n    let handler = () => {\n      setModality($507fabe10e71c6fb$var$currentModality);\n    };\n    $507fabe10e71c6fb$var$changeHandlers.add(handler);\n    return () => {\n      $507fabe10e71c6fb$var$changeHandlers.delete(handler);\n    };\n  }, []);\n  return (0, $28AnR$useIsSSR)() ? null : modality;\n}\nconst $507fabe10e71c6fb$var$nonTextInputTypes = new Set(['checkbox', 'radio', 'range', 'color', 'file', 'image', 'button', 'submit', 'reset']);\n/**\n * If this is attached to text input component, return if the event is a focus event (Tab/Escape keys pressed) so that\n * focus visible style can be properly set.\n */\nfunction $507fabe10e71c6fb$var$isKeyboardFocusEvent(isTextInput, modality, e) {\n  var _e_target;\n  const IHTMLInputElement = typeof window !== 'undefined' ? (0, $28AnR$getOwnerWindow)(e === null || e === void 0 ? void 0 : e.target).HTMLInputElement : HTMLInputElement;\n  const IHTMLTextAreaElement = typeof window !== 'undefined' ? (0, $28AnR$getOwnerWindow)(e === null || e === void 0 ? void 0 : e.target).HTMLTextAreaElement : HTMLTextAreaElement;\n  const IHTMLElement = typeof window !== 'undefined' ? (0, $28AnR$getOwnerWindow)(e === null || e === void 0 ? void 0 : e.target).HTMLElement : HTMLElement;\n  const IKeyboardEvent = typeof window !== 'undefined' ? (0, $28AnR$getOwnerWindow)(e === null || e === void 0 ? void 0 : e.target).KeyboardEvent : KeyboardEvent;\n  isTextInput = isTextInput || (e === null || e === void 0 ? void 0 : e.target) instanceof IHTMLInputElement && !$507fabe10e71c6fb$var$nonTextInputTypes.has(e === null || e === void 0 ? void 0 : (_e_target = e.target) === null || _e_target === void 0 ? void 0 : _e_target.type) || (e === null || e === void 0 ? void 0 : e.target) instanceof IHTMLTextAreaElement || (e === null || e === void 0 ? void 0 : e.target) instanceof IHTMLElement && (e === null || e === void 0 ? void 0 : e.target.isContentEditable);\n  return !(isTextInput && modality === 'keyboard' && e instanceof IKeyboardEvent && !$507fabe10e71c6fb$var$FOCUS_VISIBLE_INPUT_KEYS[e.key]);\n}\nfunction $507fabe10e71c6fb$export$ffd9e5021c1fb2d6() {\n  let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let {\n    isTextInput: isTextInput,\n    autoFocus: autoFocus\n  } = props;\n  let [isFocusVisibleState, setFocusVisible] = (0, $28AnR$useState)(autoFocus || $507fabe10e71c6fb$export$b9b3dfddab17db27());\n  $507fabe10e71c6fb$export$ec71b4b83ac08ec3(isFocusVisible => {\n    setFocusVisible(isFocusVisible);\n  }, [isTextInput], {\n    isTextInput: isTextInput\n  });\n  return {\n    isFocusVisible: isFocusVisibleState\n  };\n}\nfunction $507fabe10e71c6fb$export$ec71b4b83ac08ec3(fn, deps, opts) {\n  $507fabe10e71c6fb$var$setupGlobalFocusEvents();\n  (0, $28AnR$useEffect)(() => {\n    let handler = (modality, e) => {\n      if (!$507fabe10e71c6fb$var$isKeyboardFocusEvent(!!(opts === null || opts === void 0 ? void 0 : opts.isTextInput), modality, e)) return;\n      fn($507fabe10e71c6fb$export$b9b3dfddab17db27());\n    };\n    $507fabe10e71c6fb$var$changeHandlers.add(handler);\n    return () => {\n      $507fabe10e71c6fb$var$changeHandlers.delete(handler);\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, deps);\n}\nexport { $507fabe10e71c6fb$export$d90243b58daecda7 as hasSetupGlobalListeners, $507fabe10e71c6fb$export$2f1888112f558a7d as addWindowFocusTracking, $507fabe10e71c6fb$export$b9b3dfddab17db27 as isFocusVisible, $507fabe10e71c6fb$export$630ff653c5ada6a9 as getInteractionModality, $507fabe10e71c6fb$export$8397ddfc504fdb9a as setInteractionModality, $507fabe10e71c6fb$export$98e20ec92f614cfe as useInteractionModality, $507fabe10e71c6fb$export$ffd9e5021c1fb2d6 as useFocusVisible, $507fabe10e71c6fb$export$ec71b4b83ac08ec3 as useFocusVisibleListener };","map":{"version":3,"mappings":"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","names":["$507fabe10e71c6fb$var$currentModality","$507fabe10e71c6fb$var$changeHandlers","Set","$507fabe10e71c6fb$export$d90243b58daecda7","Map","$507fabe10e71c6fb$var$hasEventBeforeFocus","$507fabe10e71c6fb$var$hasBlurredWindowRecently","$507fabe10e71c6fb$var$FOCUS_VISIBLE_INPUT_KEYS","Tab","Escape","$507fabe10e71c6fb$var$triggerChangeHandlers","modality","e","handler","$507fabe10e71c6fb$var$isValidKey","metaKey","altKey","ctrlKey","key","$507fabe10e71c6fb$var$handleKeyboardEvent","$507fabe10e71c6fb$var$handlePointerEvent","type","$507fabe10e71c6fb$var$handleClickEvent","$507fabe10e71c6fb$var$handleFocusEvent","target","window","document","$507fabe10e71c6fb$var$handleWindowBlur","$507fabe10e71c6fb$var$setupGlobalFocusEvents","element","get","windowObject","documentObject","focus","HTMLElement","prototype","apply","arguments","addEventListener","PointerEvent","$507fabe10e71c6fb$var$tearDownWindowFocusTracking","once","set","loadListener","removeEventListener","has","delete","$507fabe10e71c6fb$export$2f1888112f558a7d","readyState","$507fabe10e71c6fb$export$b9b3dfddab17db27","$507fabe10e71c6fb$export$630ff653c5ada6a9","$507fabe10e71c6fb$export$8397ddfc504fdb9a","$507fabe10e71c6fb$export$98e20ec92f614cfe","setModality","add","$507fabe10e71c6fb$var$nonTextInputTypes","$507fabe10e71c6fb$var$isKeyboardFocusEvent","isTextInput","_e_target","IHTMLInputElement","HTMLInputElement","IHTMLTextAreaElement","HTMLTextAreaElement","IHTMLElement","IKeyboardEvent","KeyboardEvent","isContentEditable","$507fabe10e71c6fb$export$ffd9e5021c1fb2d6","props","autoFocus","isFocusVisibleState","setFocusVisible","$507fabe10e71c6fb$export$ec71b4b83ac08ec3","isFocusVisible","fn","deps","opts"],"sources":["C:\\Users\\aiwar\\Desktop\\cloth\\myy-app\\node_modules\\@react-aria\\interactions\\dist\\packages\\@react-aria\\interactions\\src\\useFocusVisible.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n// Portions of the code in this file are based on code from react.\n// Original licensing for the following can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions\n\nimport {getOwnerDocument, getOwnerWindow, isMac, isVirtualClick} from '@react-aria/utils';\nimport {useEffect, useState} from 'react';\nimport {useIsSSR} from '@react-aria/ssr';\n\nexport type Modality = 'keyboard' | 'pointer' | 'virtual';\ntype HandlerEvent = PointerEvent | MouseEvent | KeyboardEvent | FocusEvent | null;\ntype Handler = (modality: Modality, e: HandlerEvent) => void;\nexport type FocusVisibleHandler = (isFocusVisible: boolean) => void;\nexport interface FocusVisibleProps {\n  /** Whether the element is a text input. */\n  isTextInput?: boolean,\n  /** Whether the element will be auto focused. */\n  autoFocus?: boolean\n}\n\nexport interface FocusVisibleResult {\n  /** Whether keyboard focus is visible globally. */\n  isFocusVisible: boolean\n}\n\nlet currentModality: null | Modality = null;\nlet changeHandlers = new Set<Handler>();\ninterface GlobalListenerData {\n  focus: () => void\n}\nexport let hasSetupGlobalListeners = new Map<Window, GlobalListenerData>(); // We use a map here to support setting event listeners across multiple document objects.\nlet hasEventBeforeFocus = false;\nlet hasBlurredWindowRecently = false;\n\n// Only Tab or Esc keys will make focus visible on text input elements\nconst FOCUS_VISIBLE_INPUT_KEYS = {\n  Tab: true,\n  Escape: true\n};\n\nfunction triggerChangeHandlers(modality: Modality, e: HandlerEvent) {\n  for (let handler of changeHandlers) {\n    handler(modality, e);\n  }\n}\n\n/**\n * Helper function to determine if a KeyboardEvent is unmodified and could make keyboard focus styles visible.\n */\nfunction isValidKey(e: KeyboardEvent) {\n  // Control and Shift keys trigger when navigating back to the tab with keyboard.\n  return !(e.metaKey || (!isMac() && e.altKey) || e.ctrlKey || e.key === 'Control' || e.key === 'Shift' || e.key === 'Meta');\n}\n\n\nfunction handleKeyboardEvent(e: KeyboardEvent) {\n  hasEventBeforeFocus = true;\n  if (isValidKey(e)) {\n    currentModality = 'keyboard';\n    triggerChangeHandlers('keyboard', e);\n  }\n}\n\nfunction handlePointerEvent(e: PointerEvent | MouseEvent) {\n  currentModality = 'pointer';\n  if (e.type === 'mousedown' || e.type === 'pointerdown') {\n    hasEventBeforeFocus = true;\n    triggerChangeHandlers('pointer', e);\n  }\n}\n\nfunction handleClickEvent(e: MouseEvent) {\n  if (isVirtualClick(e)) {\n    hasEventBeforeFocus = true;\n    currentModality = 'virtual';\n  }\n}\n\nfunction handleFocusEvent(e: FocusEvent) {\n  // Firefox fires two extra focus events when the user first clicks into an iframe:\n  // first on the window, then on the document. We ignore these events so they don't\n  // cause keyboard focus rings to appear.\n  if (e.target === window || e.target === document) {\n    return;\n  }\n\n  // If a focus event occurs without a preceding keyboard or pointer event, switch to virtual modality.\n  // This occurs, for example, when navigating a form with the next/previous buttons on iOS.\n  if (!hasEventBeforeFocus && !hasBlurredWindowRecently) {\n    currentModality = 'virtual';\n    triggerChangeHandlers('virtual', e);\n  }\n\n  hasEventBeforeFocus = false;\n  hasBlurredWindowRecently = false;\n}\n\nfunction handleWindowBlur() {\n  // When the window is blurred, reset state. This is necessary when tabbing out of the window,\n  // for example, since a subsequent focus event won't be fired.\n  hasEventBeforeFocus = false;\n  hasBlurredWindowRecently = true;\n}\n\n/**\n * Setup global event listeners to control when keyboard focus style should be visible.\n */\nfunction setupGlobalFocusEvents(element?: HTMLElement | null) {\n  if (typeof window === 'undefined' || hasSetupGlobalListeners.get(getOwnerWindow(element))) {\n    return;\n  }\n\n  const windowObject = getOwnerWindow(element);\n  const documentObject = getOwnerDocument(element);\n\n  // Programmatic focus() calls shouldn't affect the current input modality.\n  // However, we need to detect other cases when a focus event occurs without\n  // a preceding user event (e.g. screen reader focus). Overriding the focus\n  // method on HTMLElement.prototype is a bit hacky, but works.\n  let focus = windowObject.HTMLElement.prototype.focus;\n  windowObject.HTMLElement.prototype.focus = function () {\n    hasEventBeforeFocus = true;\n    focus.apply(this, arguments as unknown as [options?: FocusOptions | undefined]);\n  };\n\n  documentObject.addEventListener('keydown', handleKeyboardEvent, true);\n  documentObject.addEventListener('keyup', handleKeyboardEvent, true);\n  documentObject.addEventListener('click', handleClickEvent, true);\n\n  // Register focus events on the window so they are sure to happen\n  // before React's event listeners (registered on the document).\n  windowObject.addEventListener('focus', handleFocusEvent, true);\n  windowObject.addEventListener('blur', handleWindowBlur, false);\n\n  if (typeof PointerEvent !== 'undefined') {\n    documentObject.addEventListener('pointerdown', handlePointerEvent, true);\n    documentObject.addEventListener('pointermove', handlePointerEvent, true);\n    documentObject.addEventListener('pointerup', handlePointerEvent, true);\n  } else {\n    documentObject.addEventListener('mousedown', handlePointerEvent, true);\n    documentObject.addEventListener('mousemove', handlePointerEvent, true);\n    documentObject.addEventListener('mouseup', handlePointerEvent, true);\n  }\n\n  // Add unmount handler\n  windowObject.addEventListener('beforeunload', () => {\n    tearDownWindowFocusTracking(element);\n  }, {once: true});\n\n  hasSetupGlobalListeners.set(windowObject, {focus});\n}\n\nconst tearDownWindowFocusTracking = (element, loadListener?: () => void) => {\n  const windowObject = getOwnerWindow(element);\n  const documentObject = getOwnerDocument(element);\n  if (loadListener) {\n    documentObject.removeEventListener('DOMContentLoaded', loadListener);\n  }\n  if (!hasSetupGlobalListeners.has(windowObject)) {\n    return;\n  }\n  windowObject.HTMLElement.prototype.focus = hasSetupGlobalListeners.get(windowObject)!.focus;\n\n  documentObject.removeEventListener('keydown', handleKeyboardEvent, true);\n  documentObject.removeEventListener('keyup', handleKeyboardEvent, true);\n  documentObject.removeEventListener('click', handleClickEvent, true);\n  windowObject.removeEventListener('focus', handleFocusEvent, true);\n  windowObject.removeEventListener('blur', handleWindowBlur, false);\n\n  if (typeof PointerEvent !== 'undefined') {\n    documentObject.removeEventListener('pointerdown', handlePointerEvent, true);\n    documentObject.removeEventListener('pointermove', handlePointerEvent, true);\n    documentObject.removeEventListener('pointerup', handlePointerEvent, true);\n  } else {\n    documentObject.removeEventListener('mousedown', handlePointerEvent, true);\n    documentObject.removeEventListener('mousemove', handlePointerEvent, true);\n    documentObject.removeEventListener('mouseup', handlePointerEvent, true);\n  }\n\n  hasSetupGlobalListeners.delete(windowObject);\n};\n\n/**\n * EXPERIMENTAL\n * Adds a window (i.e. iframe) to the list of windows that are being tracked for focus visible.\n *\n * Sometimes apps render portions of their tree into an iframe. In this case, we cannot accurately track if the focus\n * is visible because we cannot see interactions inside the iframe. If you have this in your application's architecture,\n * then this function will attach event listeners inside the iframe. You should call `addWindowFocusTracking` with an\n * element from inside the window you wish to add. We'll retrieve the relevant elements based on that.\n * Note, you do not need to call this for the default window, as we call it for you.\n *\n * When you are ready to stop listening, but you do not wish to unmount the iframe, you may call the cleanup function\n * returned by `addWindowFocusTracking`. Otherwise, when you unmount the iframe, all listeners and state will be cleaned\n * up automatically for you.\n *\n * @param element @default document.body - The element provided will be used to get the window to add.\n * @returns A function to remove the event listeners and cleanup the state.\n */\nexport function addWindowFocusTracking(element?: HTMLElement | null): () => void {\n  const documentObject = getOwnerDocument(element);\n  let loadListener;\n  if (documentObject.readyState !== 'loading') {\n    setupGlobalFocusEvents(element);\n  } else {\n    loadListener = () => {\n      setupGlobalFocusEvents(element);\n    };\n    documentObject.addEventListener('DOMContentLoaded', loadListener);\n  }\n\n  return () => tearDownWindowFocusTracking(element, loadListener);\n}\n\n// Server-side rendering does not have the document object defined\n// eslint-disable-next-line no-restricted-globals\nif (typeof document !== 'undefined') {\n  addWindowFocusTracking();\n}\n\n/**\n * If true, keyboard focus is visible.\n */\nexport function isFocusVisible(): boolean {\n  return currentModality !== 'pointer';\n}\n\nexport function getInteractionModality(): Modality | null {\n  return currentModality;\n}\n\nexport function setInteractionModality(modality: Modality) {\n  currentModality = modality;\n  triggerChangeHandlers(modality, null);\n}\n\n/**\n * Keeps state of the current modality.\n */\nexport function useInteractionModality(): Modality | null {\n  setupGlobalFocusEvents();\n\n  let [modality, setModality] = useState(currentModality);\n  useEffect(() => {\n    let handler = () => {\n      setModality(currentModality);\n    };\n\n    changeHandlers.add(handler);\n    return () => {\n      changeHandlers.delete(handler);\n    };\n  }, []);\n\n  return useIsSSR() ? null : modality;\n}\n\nconst nonTextInputTypes = new Set([\n  'checkbox',\n  'radio',\n  'range',\n  'color',\n  'file',\n  'image',\n  'button',\n  'submit',\n  'reset'\n]);\n\n/**\n * If this is attached to text input component, return if the event is a focus event (Tab/Escape keys pressed) so that\n * focus visible style can be properly set.\n */\nfunction isKeyboardFocusEvent(isTextInput: boolean, modality: Modality, e: HandlerEvent) {\n  const IHTMLInputElement = typeof window !== 'undefined' ? getOwnerWindow(e?.target as Element).HTMLInputElement : HTMLInputElement;\n  const IHTMLTextAreaElement = typeof window !== 'undefined' ? getOwnerWindow(e?.target as Element).HTMLTextAreaElement : HTMLTextAreaElement;\n  const IHTMLElement = typeof window !== 'undefined' ? getOwnerWindow(e?.target as Element).HTMLElement : HTMLElement;\n  const IKeyboardEvent = typeof window !== 'undefined' ? getOwnerWindow(e?.target as Element).KeyboardEvent : KeyboardEvent;\n\n  isTextInput = isTextInput ||\n    (e?.target instanceof IHTMLInputElement && !nonTextInputTypes.has(e?.target?.type)) ||\n    e?.target instanceof IHTMLTextAreaElement ||\n    (e?.target instanceof IHTMLElement && e?.target.isContentEditable);\n  return !(isTextInput && modality === 'keyboard' && e instanceof IKeyboardEvent && !FOCUS_VISIBLE_INPUT_KEYS[e.key]);\n}\n\n/**\n * Manages focus visible state for the page, and subscribes individual components for updates.\n */\nexport function useFocusVisible(props: FocusVisibleProps = {}): FocusVisibleResult {\n  let {isTextInput, autoFocus} = props;\n  let [isFocusVisibleState, setFocusVisible] = useState(autoFocus || isFocusVisible());\n  useFocusVisibleListener((isFocusVisible) => {\n    setFocusVisible(isFocusVisible);\n  }, [isTextInput], {isTextInput});\n\n  return {isFocusVisible: isFocusVisibleState};\n}\n\n/**\n * Listens for trigger change and reports if focus is visible (i.e., modality is not pointer).\n */\nexport function useFocusVisibleListener(fn: FocusVisibleHandler, deps: ReadonlyArray<any>, opts?: {isTextInput?: boolean}): void {\n  setupGlobalFocusEvents();\n\n  useEffect(() => {\n    let handler = (modality: Modality, e: HandlerEvent) => {\n      if (!isKeyboardFocusEvent(!!(opts?.isTextInput), modality, e)) {\n        return;\n      }\n      fn(isFocusVisible());\n    };\n    changeHandlers.add(handler);\n    return () => {\n      changeHandlers.delete(handler);\n    };\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, deps);\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}